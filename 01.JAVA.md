### 백엔드 개발자 기술 인터뷰 | JAVA 단골 질문

---

- [1. 자바의 모든 클래스는 Object 클래스의 equals()와 hashCode() 메소드의 역할 및 차이에 대해 말해주세요.](#equals--hashcode)
  - [1-1. equals() 메소드와 hashCode() 메소드의 기본 구현 방식에 대해 말해주세요.]()
  - [1-2. equals-hashCode 계약 위반 시 어떤 문제가 발생할 수 있는지에 대해 말해주세요.]()
- [2. StringBuilder와 StringBuffer의 차이에 대해 말해주세요.](#stringbuilder--stringbuffer)
  - [2-1. 멀티스레드 환경에서 StringBuilder를 사용할 때 발생할 수 있는 문제에 대해 말해주세요.]()
  - [2-2. StringBuffer가 동기화되어 있는 방식에 대해 말해주세요.]()
- [3. System.out.println 메소드 사용을 현업에서 지양하는 이유에 대해 말해주세요.](#systemoutprintln-지양-이유)
  - [3-1. 로깅 프레임워크 사용 시 주의해야 할 점에 대해 말해주세요.]()
  - [3-2. 로그 레벨의 종류와 각각의 사용 목적에 대해 말해주세요.]()
- [4. ArrayList가 내부적으로 어떻게 구현되어 있는지에 대해 말해주세요.](#arraylist-내부-구현)
  - [4-1. ArrayList의 초기 용량 및 확장 방식에 대해 말해주세요.]()
  - [4-2. LinkedList와 ArrayList의 장단점에 대해 말해주세요.]()
- [5. 스레드를 사용하는 이유에 대해 말해주세요.](#스레드-사용-이유)
  - [5-1. 스레드를 생성하고 관리하는 방법으로 어떤 것들이 있는지에 대해 말해주세요.]()
  - [5-2. 멀티스레딩에서 발생할 수 있는 주요 문제와 그 해결 방법에 대해 말해주세요.]()
- [6. 여러 스레드가 동시에 ++ 연산을 할 때 예상과 다르게 결과가 나오는 이유에 대해 말해주세요.](#스레드의--연산)
  - [6-1. 원자성을 보장하기 위한 자바의 방법에는 어떤 것들이 있는지에 대해 말해주세요.]()
  - [6-2. AtomicInteger와 synchronized의 차이점에 대해 말해주세요.]()
- [7. 자바에서 동시성과 관련된 예약어에 대해 말해주세요.](#자바-동시성-관련-예약어)
  - [7-1. synchronized와 volatile의 차이점에 대해 말해주세요.]()
  - [7-2. ConcurrentHashMap과 같은 동시성 컬렉션은 어떻게 동작하는지에 대해 말해주세요.]()
- [8. Blocking IO와 Non-Blocking IO의 차이에 대해 말해주세요.]()
  - [8-1. Non-Blocking IO를 사용했을 때 발생할 수 있는 문제점은 무엇인지에 대해 말해주세요.]()
  - [8-2. Java NIO 패키지의 주요 구성 요소에 대해 말해주세요.]()
- [9. Serializable에 대해 말해주세요.]()
  - [9-1. 직렬화 시 고려해야 할 보안 문제에 대해 말해주세요.]()
  - [9-2. Externalizable 인터페이스와 Serializable 인터페이스의 차이점에 대해 말해주세요.]()

<br>

#### equals() & hashCode()

<details>
<summary>자바의 모든 클래스는 Object 클래스의 equals()와 hashCode() 메소드의 역할 및 차이에 대해 말해주세요.</summary>

- 자바에서 모든 클래스는 Object 클래스의 기본 메서드인 equals()와 hashCode()를 상속받는다.
  - **equals()**는 두 객체의 논리적 동등성을 비교하는 메서드로, 기본 구현은 동일한 인스턴스(참조 동일성)를 검사한다.
  - **hashCode()**는 객체의 해시 값을 반환하여, 주로 해시 기반 컬렉션에서 객체를 식별하는 데 사용된다.

> 두 메서드는 equals-hashCode 계약에 따라, 두 객체가 equals()로 같으면 반드시 같은 hashCode() 값을 가져야 한다.

<details>
<summary>⁉️ equals() 메소드와 hashCode() 메소드의 기본 구현 방식에 대해 말해주세요.</summary>

- 기본적으로 Object 클래스의 equals()는 동일한 참조인지 확인하며, hashCode()는 객체의 메모리 주소를 기반으로 해시 값을 생성한다.
- 따라서 재정의하지 않으면 객체의 논리적 동등성은 올바르게 판단되지 않을 수 있다.

</details>

<br>

<details>
<summary>⁉️ equals-hashCode 계약 위반 시 어떤 문제가 발생할 수 있는지에 대해 말해주세요.</summary>

- 계약을 위반하면 HashMap, HashSet 등 해시 기반 컬렉션에서 객체를 올바르게 저장하거나 검색하지 못해 데이터 중복, 누락 또는 잘못된 조회 결과가 발생할 수 있다.

</details>

</details>

---

#### StringBuilder & StringBuffer

<details>
<summary>StringBuilder와 StringBuffer의 차이에 대해 말해주세요.</summary>

- StringBuilder와 StringBuffer 모두 문자열을 변경할 수 있는(mutable) 클래스로, 내부적으로 가변 배열을 사용한다.


- **StringBuffer**는 모든 메서드가 동기화되어 있어 스레드 안전(thread-safe)하지만, 
- **StringBuilder**는 동기화되지 않아 단일 스레드 환경에서 더 빠른 성능을 보인다.

<details>
<summary>⁉️ 멀티스레드 환경에서 StringBuilder를 사용할 때 발생할 수 있는 문제에 대해 말해주세요.</summary>

- StringBuilder는 동기화가 되어 있지 않으므로 여러 스레드가 동시에 접근하면 데이터 손상이나 일관성 문제가 발생할 수 있다.

</details>

<br>

<details>
<summary>⁉️ StringBuffer가 동기화되어 있는 방식에 대해 말해주세요.</summary>

- StringBuffer의 메서드들은 synchronized 키워드로 보호되어 있어, 한 번에 하나의 스레드만 접근할 수 있다.
- 이로 인해 멀티스레드 환경에서도 안전하게 문자열을 조작할 수 있다.

</details>

</details>

---

#### System.out.println() 지양 이유

<details>
<summary>System.out.println 메소드 사용을 현업에서 지양하는 이유에 대해 말해주세요.</summary>

- System.out.println은 디버깅이나 간단한 출력에 유용하지만, 운영 환경에서는 성능 저하, 출력 제어 부족, 로그 레벨 관리 미흡 등의 이유로 지양한다.
- 대신 Log4j, SLF4J 같은 로깅 프레임워크를 사용하면 로그 레벨 설정, 포맷 지정, 외부 저장 등 다양한 기능을 제공받을 수 있다.

<details>
<summary>⁉️ 로깅 프레임워크 사용 시 주의해야 할 점에 대해 말해주세요.</summary>

- 로그 설정 파일 관리, 로그 레벨 설정, 성능에 미치는 영향, 그리고 보안 및 민감 정보 노출 방지 등을 주의해야 한다.

</details>

<br>

<details>
<summary>⁉️ 로그 레벨의 종류와 각각의 사용 목적에 대해 말해주세요.</summary>

- 대표적인 로그 레벨에는 DEBUG(개발 및 디버깅용), INFO(일반 정보), WARN(경고), ERROR(오류), FATAL(치명적 오류)가 있으며,
- 로그 레벨에 따라 출력 여부와 상세 정보의 양을 조절한다.

</details>

</details>

---

#### ArrayList 내부 구현

<details>
<summary>ArrayList가 내부적으로 어떻게 구현되어 있는지에 대해 말해주세요.</summary>

- ArrayList는 내부적으로 가변 크기의 배열(Object[])을 사용하여 요소들을 저장한다.
- 요소 추가 시, 배열의 크기가 부족하면 새로운 배열을 할당하고 기존 요소들을 복사한다.
- 이러한 구조는 임의 접근(random access)이 빠르지만, 중간에 요소를 추가하거나 삭제할 때는 배열 이동으로 인해 성능이 떨어질 수 있다.

<details>
<summary>⁉️ ArrayList의 초기 용량 및 확장 방식에 대해 말해주세요.</summary>

- ArrayList는 기본 초기 용량을 가지고 있으며, 필요 시 용량을 약 1.5배씩 확장한다.
- 이는 배열 복사 비용을 줄이기 위한 전략이다.

</details>

<br>

<details>
<summary>⁉️ LinkedList와 ArrayList의 장단점에 대해 말해주세요.</summary>

- ArrayList는 임의 접근이 빠르지만, 중간 삽입 및 삭제가 느리고, 
- LinkedList는 삽입 및 삭제가 빠르지만 임의 접근이 느리다.

</details>

</details>

---

#### 스레드 사용 이유

<details>
<summary>스레드를 사용하는 이유에 대해 말해주세요.</summary>

- 스레드는 한 프로세스 내에서 여러 작업을 동시에 수행할 수 있도록 하여 CPU의 멀티코어 활용, I/O 대기 시간 동안 다른 작업 수행, 응답성 향상 등의 이점을 제공한다.
- 이를 통해 프로그램의 효율성과 사용자 경험을 개선할 수 있다.

<details>
<summary>⁉️ 스레드를 생성하고 관리하는 방법으로 어떤 것들이 있는지에 대해 말해주세요.</summary>

- Thread 클래스를 상속하거나 Runnable 인터페이스를 구현하는 방법이 있으며, Executor Framework를 활용하여 스레드 풀로 관리할 수 있다.

</details>

<br>

<details>
<summary>⁉️ 멀티스레딩에서 발생할 수 있는 주요 문제와 그 해결 방법에 대해 말해주세요.</summary>

- 레이스 컨디션, 데드락, 스레드 간의 자원 경쟁 등이 있으며, 
- 동기화(synchronized), volatile, Lock과 같은 메커니즘으로 해결할 수 있다.

</details>

</details>

---

#### 스레드의 ++ 연산

<details>
<summary>여러 스레드가 동시에 ++ 연산을 할 때 예상과 다르게 결과가 나오는 이유에 대해 말해주세요.</summary>

- ++ 연산은 읽기-수정-쓰기 세 단계로 이루어지며, 원자적 연산이 아니다.
- 여러 스레드가 동시에 ++ 연산을 수행하면, 각 스레드가 값을 읽은 후 수정하고 쓰는 과정에서 중복되거나 덮어쓰게 되어, 최종 결과가 예상 값보다 작게 나올 수 있다.

<details>
<summary>⁉️ 원자성을 보장하기 위한 자바의 방법에는 어떤 것들이 있는지에 대해 말해주세요.</summary>

- synchronized, volatile, 그리고 AtomicInteger와 같은 java.util.concurrent.atomic 패키지의 클래스를 사용할 수 있다.

</details>

<br>

<details>
<summary>⁉️AtomicInteger와 synchronized의 차이점에 대해 말해주세요. </summary>

- AtomicInteger는 Lock 없이도 원자적 연산을 지원해 성능이 우수하지만, 
- 복잡한 동기화가 필요한 경우에는 synchronized가 유연한 제어를 제공한다.

</details>

</details>

---

#### 자바 동시성 관련 예약어

<details>
<summary>자바에서 동시성과 관련된 예약어에 대해 말해주세요.</summary>

- 자바에서는 synchronized와 volatile 두 가지 주요 동시성 예약어를 제공한다.


- synchronized는 특정 블록이나 메서드에 대해 한 번에 하나의 스레드만 접근할 수 있도록 잠금(Lock) 기능을 제공한다.
- volatile은 변수의 값을 메인 메모리에서 읽고 쓸 수 있도록 하여, 여러 스레드 간의 가시성을 보장한다.

<details>
<summary>⁉️ synchronized와 volatile의 차이점에 대해 말해주세요.</summary>

- synchronized는 임계 영역을 보호하여 동시에 하나의 스레드만 접근하게 하지만, 
- volatile은 변수의 최신 값을 보장해주며, 동기화처럼 상호 배제를 제공하지 않는다.

</details>

<br>

<details>
<summary>⁉️ </summary>
</details>

</details>

---

#### 

<details>
<summary></summary>

-

<details>
<summary>⁉️ </summary>
</details>

<br>

<details>
<summary>⁉️ </summary>
</details>

</details>

---

#### 

<details>
<summary></summary>

-

<details>
<summary>⁉️ </summary>
</details>

<br>

<details>
<summary>⁉️ </summary>
</details>

</details>

---
