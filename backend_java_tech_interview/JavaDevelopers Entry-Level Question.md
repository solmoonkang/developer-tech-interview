### 백엔드 개발 자바 기술 면접 | 신입 개발자 JAVA 단골 질문

---

- [1. 컴파일 과정을 말해주세요.](#컴파일-과정)
    - [1-1. Compiler와 Interpreter의 차이에 대해 말해주세요.]()
- [2. String, StringBuilder, StringBuffer의 차이점에 대해 말해주세요.](#string-stringbuilder-stringbuffer의-차이)
    - [2-1. Thread Safe에 대해서 말해주세요.]()
    - [2-2. Java String이 불변 객체인 이유에 대해서 말해주세요.]()
- [3. Java의 접근 제어자의 종류와 특징](#java의-접근-제어자의-종류와-특징)
- [4. OOP의 4가지 특징에 대해서 말해주세요.](#oop의-4가지-특징)
    - [4-1. 캡슐화와 은닉화의 차이에 대해서 말해주세요.]()
- [5. OOP의 5대 원칙 (SOLID)에 대해서 말해주세요.](#oop의-5대-원칙-solid)
- [6. JVM의 구조에 대해서 말해주세요.](#jvm의-구조)
- [7. 클래스, 객체, 인스턴스의 차이에 대해서 말해주세요.](#클래스-객체-인스턴스의-차이)
- [8. Interface와 Abstract Class의 차이에 대해서 말해주세요.](#interface와-abstract-class의-차이)
- [9. CheckedException과 UnCheckedException의 차이에 대해서 말해주세요.](#checkedexception과-uncheckedexception의-차이)
- [10. Call By Reference와 Call By Value의 차이에 대해서 말해주세요.](#call-by-reference와-call-by-value의-차이)
    - [10-1. Java는 어디에 해당하는지 알려주세요.]()
- [11. 오버로딩과 오버라이딩의 차이에 대해서 말해주세요.](#오버로딩과-오버라이딩의-차이)

<br>

#### 컴파일 과정

<details>
<summary>컴파일 과정을 말해주세요.</summary>

![Java 코드의 실행 과정](/image_files/JAVA/java-execution-process.png)

1. **소스 코드 작성**: 개발자가 `.java` 파일을 작성하고, 코드 작성 후 빌드 과정에 들어간다.


2. **컴파일**: Java 컴파일러의 `javac` 명령어를 사용해 소스 코드를 바이트 코드로 구성된 `.class` 파일로 변환한다.


3. **클래스 로드**: 컴파일된 `.class` 파일을 클래스 로더에 의해서 JVM 메모리 영역에 로드한다.

![JVM의 구조(클래스 로더와 실행 엔진)](/image_files/JAVA/class-loader&execution-engine.png)

클래스 로더가 불러오는 과정은 다음과 같은 과정을 거친다.

- **로드**: 클래스 파일을 JVM 메모리에 가져온다.
- **검증**: 클래스가 JVM 명세를 따르는지 검사한다.
- **준비**: 필요한 메모리를 할당한다.
- **분석**: 심볼릭 레퍼런스를 다이렉트 레퍼런스로 변환한다.
- **초기화**: 클래스 변수를 초기화한다.

> 클래스 로더는 계층적으로 존재하면서 상위 클래스 로더가 가져온 내용을 먼저 확인하고 찾지 못하면 하위 클래스 로더가 클래스를 로드하게 된다.

4. **실행 엔진**: JVM에 들어온 바이트 코드는 실행 엔진에 의해 JVM 내에서 기계어로 변환되어 실행된다.

JVM 실행 엔진은 인터프리터 방식과 JIT 컴파일러 방식으로 나눠지며 각 특징은 다음과 같다.

- **인터프리터**: 바이트 코드를 하나씩 해석하고 실행한다. 초기 실행이 간단하고 빠른 반면, 전체 실행 속도는 느리다.
- **JIT 컴파일러**: 전체 바이트 코드를 컴파일하여 바이너리 코드로 실행한다. 변환된 코드는 이후 재사용되므로 전체 실행 속도가 빠르다.

> JVM은 기본적으로 인터프리터 방식을 사용하고 내부적으로 특정 메서드가 자주 호출되면, JIT 컴파일러가 활성화되어 해당 코드를 컴파일하여 성능을 개선한다.

<details>
<summary>⁉️ Compiler와 Interpreter의 차이에 대해서 말해주세요.</summary>

- **컴파일러**: 전체 소스 코드를 한 번에 분석하여 기계어로 번역하며, 실행 가능한 실행 파일이나 바이트 코드(`.class` 파일)를 생성한다.
    - 컴파일이 완료된 후 실행 속도가 빠르지만, 초기 컴파일 시간이 필요하다.
- **인터프리터**: 소스 코드를 한 줄씩 읽어 즉시 실행하며, 별도의 실행 파일을 생성하지 않고 코드가 실행되는 동안 해석한다.
    - 각 줄마다 해석해야 하므로 실행 속도가 느리다.

> Java에서 `javac`가 컴파일러 역할을 하며, Python의 인터프리터가 이에 해당한다.

</details>

</details>

---

#### String, StringBuilder, StringBuffer의 차이

<details>
<summary>String, StringBuilder, StringBuffer의 차이점에 대해 말해주세요.</summary>

- **String 객체**: 불변(Immutable) 객체로 한 번 생성된 문자열은 변경할 수 없다. 때문에 변하지 않는 문자열을 저장할 때 적합하다.
    - 메모리 안정성 및 Thread-Safe를 제공하는 반면, 문자열을 자주 변경할 경우 성능 저하가 발생할 수 있다.

- **StringBuilder**: 가변(Mutable) 객체로 비동기 방식으로 동작한다. 문자열을 자주 변경해야 할 때 적합하다.
    - 비동기 방식이므로 처리 속도가 빠르고, 메모리 사용 효율이 좋은 반면, 멀티스레드 환경에서는 Thread-Safe하지 않다.
- **StringBuffer**: 가변(Mutable) 객체로 동기 방식으로 동작한다. 문자열을 변경할 수 있으며, 멀티스레드 환경에서 사용된다. 멀티스레드 환경에서 문자열을 변경할 때 적합하다.
    - Thread-Safe를 제공하여 동시 접근이 가능한 반면, StringBuilder보다 성능이 느리다.

> 질문의 의도는 동기와 비동기의 기준에 따라 적절한 클래스를 선택하는 것으로 보인다.

<details>
<summary>⁉️ Thread-Safe란 무엇인지 말해주세요.</summary>

- Thread-Safe는 여러 스레드가 동시에 접근할 때도 데이터의 일관성과 안정성을 보장하는 프로그래밍 기법이다.
- Thread-Safe한 코드는 여러 스레드가 동시에 실행되더라도 프로그램이 예기치 않게 동작하지 않도록 한다.
    - 동기화(synchronization), 불변 객체(immutable objects), 또는 원자적 연산(atomic)을 통해 구현된다.
- 멀티스레드 환경에서도 데이터 무결성을 유지하며 버그를 방지하는 반면, 성능 저하를 초래할 수 있으며 복잡한 동기화 로직이 필요할 수 있다.

> 동기 방식인 StringBuffer는 Thread-Safe하고, 비동기 방식인 StringBuilder는 Thread-Safe하지 않다.

</details>

<br>

<details>
<summary>⁉️ Java String이 불변 객체인 이유에 대해서 말해주세요.</summary>

- 불변 객체는 한 번 생성된 후 상태가 변경되지 않는 객체이다.

1. **메모리 안정성**: 불변 객체는 여러 스레드에서 동시에 사용될 때 안정성을 제공한다. 데이터가 변경되지 않기 때문에 스레드 간의 충돌이 없다.
2. **캐싱 효율성**: 메모리에서 동일한 값을 가진 객체를 재사용할 수 있어 메모리 효율성을 높인다. 같은 문자열 리터럴은 동일한 객체로 참조된다.
3. **안정성**: String 객체는 프로그램의 다른 부분에서 의도치 않게 변경되는 것을 방지한다. 이는 코드의 예측 가능성을 높이고 디버깅을 용이하게 한다.
4. **해시 코드 일관성**: 불변 객체는 해시 코드가 변하지 않기 때문에 해시 기반 컬렉션에서 안정적으로 사용할 수 있다.

> Java에서 String은 불변 객체로 설계되어, 메모리 안정성과 Thread-Safe를 제공하며, 해시 기반 컬렉션에서 안전하게 사용될 수 있도록 하기 위함이다.

</details>

</details>

---

#### Java의 접근 제어자의 종류와 특징

<details>
<summary>Java에서 접근 제어자의 종류와 특징에 대해 말해주세요.</summary>

- **private**: 해당 클래스 내에서만 접근이 가능하다. 클래스 내부의 데이터 은닉을 위해 사용한다.
- **default**(package-private): 접근 제어자가 명시되지 않은 경우, 동일 패키지 내의 클래스에서만 접근이 가능하다. 패키지 내부에서만 사용하고 싶을 때 사용한다.
- **protected**: 동일 패키지 내의 클래스와, 다른 패키지의 서브클래스에서 접근이 가능하다. 상속 관계에서 유용하다.
- **public**: 모든 클래스에서 접근이 가능하다. 다른 패키지에서도 사용이 가능하다.

| 접근 제어자    | 접근 가능 범위       |
|-----------|----------------|
| public    | 모든 클래스         |
| protected | 동일 패키지 + 서브클래스 |
| default   | 동일 패키지         |
| private   | 해당 클래스 내부      |

> 클래스 내 클래스를 inner 클래스라 부르며, inner 클래스도 접근 제어자로 접근을 제어할 수 있다.

</details>

---

#### OOP의 4가지 특징

<details>
<summary>OOP의 4가지 특징에 대해서 말해주세요.</summary>

1. **추상화, Abstraction**

---

공통의 속성이나 특징을 묶어 추출하여 정의한 것을 의미한다.

- 대상의 본질적인 특징을 정의하고, 이를 기반하여 대상을 객체로 구현하는 것을 의미한다.
- 대표적으로 추상 클래스(Abstract Class)와 인터페이스(Interface)가 있다.

<br>

2. **캡슐화, Encapsulation**

---

연관된 속성이나 함수를 하나로 묶어 외부로부터의 접근을 최소화하는 것을 의미한다.

- 캡슐화를 통해 정보를 객체 안에 포함시키고, 외부로부터 직접 접근을 허용하지 않는다.
- 외부에는 필요한 정보만 노출하고, 내부의 상세한 동작은 은닉한다.

<br>

3. **상속, Inherutance**

---

대상을 객체로 추상화 혹은 구현할 때, 기존에 구현한 클래스를 재활용하여 구현할 수 있는 것을 의미한다.

- 이때, 재활용한 클래스를 상위 클래스, 재활용한 클래스를 구현한 클래스를 하위 클래스라고 한다.

<br>

4. **다형성, Polymorphism**

---

어떤 객체의 속성이나 기능이 상황에 따라 여러 형태로 변할 수 있다는 것을 의미한다.

- 상속 혹은 구현 상황에서 메서드 오버라이딩과 오버로딩이 있다.
- 다형성을 통해 개발 유연성과 코드 재사용성을 제고시킬 수 있으며, 상위 객체의 타입으로 하위 객체를 참조할 수 있다.

<details>
<summary>⁉️ 추상 클래스와 인터페이스의 차이에 대해서 말해주세요.</summary>

- **추상 클래스**: 일부 메서드의 구현을 가질 수 있으며, 단일 상속을 통해 공통 기능을 공유하는 데 사용된다.
    - 추상 클래스는 인스턴스 변수와 메서드를 가질 수 있다.
- **인터페이스**: 메서드의 선언만 포함하고 실제 구현은 제공하지 않으며, 다중 상속을 통해 여러 클래스에서 구현할 수 있는 기능의 계약을 정의하는 데 사용된다.
    - 인터페이스는 상수만 가질 수 있고, 디폴트 메서드를 통해 기본 구현을 제공할 수 있다.

> 추상 클래스는 단일 상속을 지원하며, 상태를 가지고 일부 구현을 제공할 수 있는 반면, 인터페이스는 구현을 제공하지 않고 다중 상속이 가능하다.

</details>

<br>

<details>
<summary>⁉️ 캡슐화와 은닉화의 차이에 대해서 말해주세요.</summary>

- **캡슐화**: 데이터와 메서드를 하나의 단위로 묶어 객체의 내부 구조와 동작을 통합하는 개념이다.
    - OOP의 기본 원칙 중 하나로, 객체의 내부 구조를 숨기고 외부에서 접근할 수 있는 인터페이스를 제공하는 데 초점을 맞춰 높은 수준의 독립성을 가지게 된다.
- **은닉화**: 객체의 내부 구현 세부 사항을 숨기는 과정으로, 데이터 보호 및 접근 제한을 목표로 한다.
    - 주로 접근 제어자를 통해 이루어지며, private 변수로 외부에서 직접 접근하지 못하게 하고, Getter와 Setter를 통해 간접적으로 접근할 수 있도록 한다.
    - 이를 통해 데이터의 안정성과 무결성을 보장하는 역할을 한다.

> 캡슐화는 외부와의 상호작용을 위한 인터페이스를 제공하는 반면, 객체 내부의 데이터 보호를 위해 접근을 제한해 간접적으로 접근하도록 한다.

</details>

</details>

---

#### OOP의 5대 원칙 (SOLID)

<details>
<summary>OOP의 5대 원칙 (SOLID)에 대해 말해주세요.</summary>

- **단일 책임 원칙 - SRP (Single Responsibility Principle)**
---

클래스 혹은 객체는 단 하나의 책임을 가져야 한다는 원칙이다.
  - 하나의 클래스는 하나의 기능을 담당하여 하나의 책임을 수행하는 데 집중하도록 클래스를 따로따로 설계하라는 원칙이다.
  - 단일 책임 원칙의 목적은 책임의 변경으로부터 다른 책임의 변경으로 연쇄작용을 극복하여 프로그램 유지보수성을 높이기 위한 설계이다.
> 책임의 범위는 정해져 있는 것이 아닌 어떤 프로그램을 어떻게 개발하느냐에 따라 생각의 기준이 달라질 수 있다.

<br>

- **개방 폐쇄 원칙 - OCP (Open Closed Principle)**
---

확장에 열려있어야 하며, 수정에는 닫혀있어야 한다는 원칙이다.
  - 기능 추가 요청이 오면 확장을 통해 손쉽게 구현하면서, 확장에 따른 클래스 수정은 최소화하도록 설계하라는 원칙이다.
  
  
  - 확장에 열려있다: 새로운 변경사항이 발생했을 때, 유연하게 코드를 추가함으로써 애플리케이션의 기능을 확장할 수 있다.
  - 변경에 닫혀있다: 새로운 변경사항이 발생했을 때, 객체를 직접적으로 수정하는 것을 제한한다.
> OCP는 추상화 사용을 통한 관계 구축을 권장하며, 다형성과 확장을 가능케하는 OOP의 장점을 극대화한 설계 원칙이다.

<br>

- **리스코프 치환 원칙 - LSP (Liskov Substitition Principle)**
---

하위 클래스 인스턴스는 상위 클래스 인스턴스의 역할을 하는데 문제가 없어야 한다는 원칙이다.
  - 다형성의 특징을 이용해 업캐스팅된 상태에서 부모의 메서드를 사용해도 동작이 의도대로 흘러가야 한다.
  - 부모 클래스와 동일한 수준의 선행 조건을 기대하고 사용하는 코드에서는 부모 메서드의 오버라이딩을 조심스럽게 따져가야 한다.


  - Collection 타입의 객체에서 자료형을 LinkedList를 사용하다가 HashSet으로 바꿔도 add( ) 메서드를 실행하는 데 있어 문제없이 동작한다.
> 다형성을 이용해 부모 타입의 메서드로 실행해도 의도대로 실행되도록 구성을 해줘야 하는 설계 원칙이다.

<br>

- **인터페이스 분리 원칙 - ISP (Interface Segregation Principle)**
---

인터페이스를 각 사용에 맞도록 잘게 분리해야 한다는 설계 원칙이다.
  - SRP의 목표는 클래스 분리를 통한 단일 책임을 강조한다면, ISP의 목표는 인터페이스 분리를 통한 단일 책임을 강조한다.
  - 클라이언트의 목적과 용도에 적합한 인터페이스만을 제공하는 것이 목표이다.
  - 다만, 인터페이스를 분리하여 구성한 후 수정사항이 생겨 다시 인터페이스를 분리하는 행위는 가하지 않아야 한다.
> 자유롭게 다중 상속이 가능한 인터페이스는 분리할 수 있다면 분리해서 각 클래스 용도에 맞게 구현하라는 설계 원칙이다.

<br>

- **의존 역전 원칙 - DIP (Dependency Inversion Principle)**
---

대상의 상위 요소인 추상 클래스 혹은 인터페이스를 참조해야 한다는 설계 원칙이다.
  - 구현 클래스에 의존하는 것이 아닌, 인터페이스에 의존해야 한다.
  - 의존 관계를 맺을 때는 변화하기 쉬운 것이나 자주 변화하는 것보다는 변화하기 어려운 혹은 변화가 없는 것에 의존해야 한다.
> DIP의 지향점은 각 클래스 간의 결합도를 낮추는 것이 설계 원칙이다.

</details>

---

#### JVM의 구조

<details>
<summary>JVM의 구조에 대해서 말해주세요.</summary>

- **자바 가상 머신(JVM)의 동작 방식**
---

1. 자바 프로그램을 실행하면 JVM은 OS로부터 메모리를 할당받는다.
2. 자바 컴파일러(`javac`)가 자바 소스코드(`.java`)를 자바 바이트 코드(`.class`)로 컴파일한다.
3. Class Loader는 동적 로딩을 통해 필요한 클래스들을 로딩 및 링크하여 Runtime Data Area(실질적인 메모리를 할당받아 관리하는 영역)에 올린다.
4. Runtime Data Area에 로딩된 바이트 코드는 Execution Engine을 통해 해석된다.
5. 이 과정에서 Execution Engine에 의해 Garbage Collector의 작동과 Thread 동기화가 이루어진다.
> 자바 소스 코드 -> 컴파일러 -> 바이트 코드 -> 클래스 로더 -> 메모리 영역에 로드 -> 실행 엔진 -> 바이트 코드 실행

<br>

- **자바 가상 머신(JVM)의 구조**
---

JVM은 다음과 같이 구성되어 있다.

- **클래스 로더, Class Loader**: .class 파일을 찾아서 로드하고, 메모리에 적재하는 역할을 한다.
  - 로딩, Loading: 클래스 파일을 읽어 메모리에 로드한다.
  - 링크, Linking: 클래스 간의 참조를 확인하고, 필요한 메모리를 할당한다.
  - 초기화, Initalization: 클래스의 정적 초기화 블록을 실행한다.


- **실행 엔진, Execution Engine**: 바이트 코드를 실행하는 역할을 한다.
  - 인터프리터, Interpreter: 바이트 코드를 한 줄씩 해석하여 실행한다.
  - JIT 컴파일러, Just-in-Time: 자주 호출되는 바이트 코드를 기계어로 변환하여 성능을 개선한다.
  - 가비지 콜렉터, Garbage Collector: 더 이상 사용되지 않는 메모리를 자동으로 회수하여 메모리 관리를 수행한다.


- **런타임 데이터 영역, Runtime Data Area**
  - 메서드 영역, Method Area: 클래스 정보, 상수, 정적 변수 등을 저장한다.
  - 힙 영역, Heap Area: 객체 인스턴스와 배열을 저장하는 공간이다.
  - PC 레지스터, Program Counter Register: 현재 실행 중인 JVM 명령의 주소를 저장한다.
  - 네이티브 메서드 스택, Native Method Stack: 네이티브 메서드 호출 시 사용되는 스택이다.


- **네이티브 인터페이스, Native Interface**: Java와 네이티브 라이브러리 간의 연결을 제공한다.
  - JNI(Java Native Interface)를 통해 자바 코드에서 네이티브 메서드를 호출할 수 있다.

</details>

---

#### 클래스, 객체, 인스턴스의 차이

<details>
<summary>클래스, 객체, 인스턴스의 차이에 대해서 말해주세요.</summary>

- **클래스, Class**: 객체를 생성하기 위한 설계도 또는 템플릿으로 속성(변수)과 행동(메서드)을 정의한다.
- **객체, Object**: 클래스에서 정의한 속성과 행동을 가진 실제 존재로, 클래스의 구체적인 구현체이다.
- **인스턴스, Instance**: 특정 클래스의 객체를 지칭하는 용어로, 클래스의 구체적인 객체를 의미한다.

> 클래스는 객체를 정의하는 설계도, 객체는 클래스의 실제 구현체, 인스턴스는 클래스에서 만들어진 객체를 의미한다.

</details>

---

#### Interface와 Abstract Class의 차이

<details>
<summary>Interface와 Abstract Class의 차이에 대해서 말해주세요.</summary>

</details>

---

#### CheckedException과 UnCheckedException의 차이

<details>
<summary>CheckedException과 UnCheckedException의 차이에 대해서 말해주세요.</summary>

</details>

---

#### Call By Reference와 Call By Value의 차이

<details>
<summary>Call By Reference와 Call By Value의 차이에 대해서 말해주세요.</summary>

</details>

---

#### 오버로딩과 오버라이딩의 차이

<details>
<summary>오버로딩과 오버라이딩의 차이에 대해서 말해주세요.</summary>

</details>
